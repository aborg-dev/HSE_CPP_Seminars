# Советы по оформлению кода на Code Review

- У типа std::string есть дефолтный конструктор, который инициализирует его пустой строкой, так что необходимости в дополнительной инициализации нет.
 Аналогичная ситуация с std::vector<T>. Конструктор по-умолчанию создаст пустой вектор.
 В более общем случае, подобное утверждение верно почти для всех стандартных сложных типов (std::string, std::vector, std::set) и для них не нужна подобная инициализация.
 Случаи, когда она нужна - любые POD типа (int, char, float).

- const auto&, const function argument 
Входные параметры фукнции, которые не изменяются, но принимаются по ссылке надо помечать как const.
Замечу, что это стандартная ситуация, все операторы и компараторы обычно имеют сигнатуру вида (const T& lhs, const T& rhs).

- Пустой вектор можно создать через braced initialization:
    results[key] = {};
    Здесь произойдет автоматическая конверсия из {} в вектор соответствующего типа.
    
- Функции обычно называют глаголами, которые описывают действие, которое эта функция выполняет, либо предикатами вида IsSomething.
    По названию фукнции и аргументом совершенно непонятно что она делает.

- Переменные желательно объявлять как можно ближе к месту их первого использования потому что так будет проще найти их объявление, когда кода много.

- Если хочется обратиться к последнему элементу вектора по ссылке есть отличный метод std::vector<T>::back() !
 students.back().universities.push_back(university_name);

- Есть простой трюк как упрощать компараторы
 Например, мы хотим отсортировать тройки чисел p(x, y, z) сначала по возрастанию x, при равенстве x по возрастанию y, при равенстве x и y по возрастанию z.
 Тогда можно написать следующий код

 bool operator < (const Point& a, const Point& b) {
     if (a.x != b.x) { 
         return a.x < b.x;
     }
     if (a.y != b.y) {
         return a.y < b.y;
     }
     return a.z < b.z;
     }

 Как видно, тут получилось избавится от множества &&, которые присутствуют в вашем решении.
 Попробуйте применить ту же технику для упрощения вашего выражения.

